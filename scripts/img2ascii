#!/usr/bin/env python3
"""
img2ascii — Convert an image to ANSI true-color ASCII art (jp2a-style).

Usage:
    img2ascii <image> [width] [height] [output_file]

Examples:
    img2ascii Jin-Woo_Purple.webp 33 30 config/jinwoo.art
    img2ascii photo.jpg 60

Options:
    width        Character columns  (default: 33)
    height       Character rows     (default: auto, preserving aspect ratio)
    output_file  Save to file       (default: print to stdout)

Character density ramp mirrors jp2a: space = darkest, @ = brightest.
Each character is wrapped in an ANSI true-color foreground code so the
output retains the original image colors in any 24-bit terminal.
"""

import sys
from pathlib import Path

try:
    from PIL import Image
except ImportError:
    print("Error: Pillow is required.  Run: pip install pillow", file=sys.stderr)
    sys.exit(1)

# Density ramp — same philosophy as jp2a (sparse → dense)
RAMP = (
    " .`^\",:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@"
)


def _open_as_rgb(path: str) -> Image.Image:
    """Open any image (including webp / RGBA) and return an RGB image."""
    img = Image.open(path)
    if img.mode in ("RGBA", "LA", "PA"):
        bg = Image.new("RGBA", img.size, (0, 0, 0, 255))
        if img.mode == "PA":
            img = img.convert("RGBA")
        bg.paste(img, mask=img.split()[-1])
        return bg.convert("RGB")
    if img.mode == "P":
        return img.convert("RGB")
    return img.convert("RGB")


def convert(img_path: str, width: int = 33, height: int | None = None) -> list[str]:
    """
    Return a list of strings — one per row — each containing ANSI escape
    codes that set the true-color foreground before every character, then
    reset at the end of the row.
    """
    img = _open_as_rgb(img_path)
    orig_w, orig_h = img.size

    # Auto-height: terminal chars are roughly twice as tall as wide,
    # so multiply by 0.5 to keep the perceived aspect ratio square.
    if height is None:
        height = max(1, round(orig_h / orig_w * width * 0.5))

    img = img.resize((width, height), Image.LANCZOS)

    ramp_len = len(RAMP) - 1
    lines: list[str] = []

    for y in range(height):
        parts: list[str] = []
        for x in range(width):
            r, g, b = img.getpixel((x, y))
            luma = int(0.299 * r + 0.587 * g + 0.114 * b)
            ch   = RAMP[round(luma / 255 * ramp_len)]
            parts.append(f"\x1b[38;2;{r};{g};{b}m{ch}")
        lines.append("".join(parts) + "\x1b[0m")

    return lines


def main() -> None:
    args = sys.argv[1:]
    if not args:
        print(__doc__, file=sys.stderr)
        sys.exit(1)

    img_path = args[0]
    width    = int(args[1]) if len(args) > 1 else 33
    height   = int(args[2]) if len(args) > 2 else None
    out_path = args[3] if len(args) > 3 else None

    if not Path(img_path).exists():
        print(f"Error: file not found: {img_path}", file=sys.stderr)
        sys.exit(1)

    lines = convert(img_path, width, height)

    if out_path:
        Path(out_path).parent.mkdir(parents=True, exist_ok=True)
        with open(out_path, "w", encoding="utf-8") as fh:
            fh.write("\n".join(lines) + "\n")
        print(f"Saved {len(lines)} rows → {out_path}", file=sys.stderr)
    else:
        for line in lines:
            print(line)


if __name__ == "__main__":
    main()
